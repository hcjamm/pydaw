DAW Design Spec
(because writing code and then figuring out how you're going to do the rest of it is really stupid)

GUIDING PRINCIPLES:

1.  You don't need 15 different ways to do the same damn thing...  In fact, you only need one good way...
2.  The workflow should be efficient, and make sense for the way music will actually be made in it
3.  UI is completely detached from the audio engine, so when my StankQt_UI v1.0 is obsoleted by my future CompetentOpenGL_UI v1.0, I won't have to spend countless nights untangling the 2...   Maybe even the underpinnings will just be a library that can be called by the UI...
4.  It will use Events/Signals/Slots/hell-if-I-know for inter-thread communication?
5.  Threading:  1 per core, or maybe just say fuck-it and let the OS handle each instrument as a process?  grouping function calls into a thread is undoubtedly more efficient, but context switches probably aren't THAT expensive, and bad multithreading is probably what makes the current Linux DAWs such steaming piles of doo-doo...

Language:  C backend, liberally allocating memory to avoid m/re/c-allocing it while running...  If 1GB of memory is allocated at startup, then so be it...  Performance and latency are key, screw low-spec and older PCs...  Front end:  unknown, probably an original canvassing type library using either OpenGL, SDL or Cairo...

Technologies:  Jack, just Jack...  Unless that sucks by itself, then throw in ALSA, but no DSSI, LADSPA, and especially no LV2

1. Audio/MIDI item:  A single type for audio or MIDI...  To simplify maintaining a collection of items...  The items are not to have their type changed during run-time arbitrarily...  Really needs some well thought out editing functions like change_note_length(), etc..

2. Track:  Maintains an array of types contain audio_midi_item* , position, length/rate, etc...  REALLY NEED TO HAVE ALL FEATURES PLANNED BEFORE CODING.  Each reference to the item will contain the stretch/fadeout, etc.. settings, this must be planned carefully...

Routing:

Consideration for what gets routed to where, and how much...  Function pointer arrays and indexing algorithms  
to do all of the magic...

Automation:  MIDI CCs, most likely, need to think about lanes vs. items, or maybe just lanes of items, which
are all envelopes? Need to integrate my patented "don't-duplicate-cc-values-like-a-freaking-idiot" technology
Also intelligently returning pitchbend values to zero == win

Select a keyboard device and move it around radio-button style...

Snap settings?  Don't allow free positioning, but allow padding????  Hmmmm.....  Maybe make audio positioning
padded, and give MIDI an offset???

Make some careful considerations for sample-accuracy, and maybe even not make my synths/sampler JACK instruments,
but internal-only?

A channel can have one synth OR an audio input, and several Modulex instances?

Whenever there is an actual UI:  Consider alternatives to displaying waveforms or MIDI note graphs, maybe just
a plain "AUDIO" or "MIDI" label on the item, the item's name, and then editing happening in a separate pane below?

Ghosting of items...

File Saving:  Probably a plain text format like my others, once again giving XML 'the finger' (or not).  Instruments will have their own state files(just like they do now) so as not to be tied to the project(aka, you can copy the files elsewhere...)

Warp-markering type setup for audio, to make it suitable for DJing...


EDITING:

A marquee selector, and SHIFT->CLICK and CTRL->CLICK?  Maybe something like little copy checkboxes on the items instead of CTRL->click..

Splitting(or only copying/pasting partial items)



DAW Design Spec
(because writing code and then figuring out how you're going to do the rest of it is really stupid)

GUIDING PRINCIPLES:

1.  You don't need 15 different ways to do the same damn thing...  In fact, you only need one good way...
2.  The workflow should be efficient, and make sense for the way music will actually be made in it
3.  UI is completely detached from the audio engine, so when my StankQt_UI v1.0 is obsoleted by my future CompetentOpenGL_UI v1.0, I won't have to spend countless nights untangling the 2...   Maybe even the underpinnings will just be a library that can be called by the UI...
4.  It will use Events/Signals/Slots/hell-if-I-know for inter-thread communication?
5.  Threading:  1 per core, or maybe just say fuck-it and let the OS handle each instrument as a process?  grouping function calls into a thread is undoubtedly more efficient, but context switches probably aren't THAT expensive, and bad multithreading is probably what makes the current Linux DAWs such steaming piles of doo-doo...

Language:  C backend, liberally allocating memory to avoid m/re/c-allocing it while running...  If 1GB of memory is allocated at startup, then so be it...  Performance and latency are key, screw low-spec and older PCs...  Front end:  unknown, probably an original canvassing type library using either OpenGL, SDL or Cairo...

Technologies:  Jack, just Jack...  Unless that sucks by itself, then throw in ALSA, but no DSSI, LADSPA, and especially no LV2

1. Audio/MIDI item:  A single type for audio or MIDI...  To simplify maintaining a collection of items...  The items are not to have their type changed during run-time arbitrarily...  Really needs some well thought out editing functions like change_note_length(), etc..

2. Track:  Maintains an array of types contain audio_midi_item* , position, length/rate, etc...  REALLY NEED TO HAVE ALL FEATURES PLANNED BEFORE CODING.  Each reference to the item will contain the stretch/fadeout, etc.. settings, this must be planned carefully...

Routing:

Consideration for what gets routed to where, and how much...  Function pointer arrays and indexing algorithms  
to do all of the magic...

Automation:  MIDI CCs, most likely, need to think about lanes vs. items, or maybe just lanes of items, which
are all envelopes? Need to integrate my patented "don't-duplicate-cc-values-like-a-freaking-idiot" technology
Also intelligently returning pitchbend values to zero == win

Select a keyboard device and move it around radio-button style...

Snap settings?  Don't allow free positioning, but allow padding????  Hmmmm.....  Maybe make audio positioning
padded, and give MIDI an offset???

Make some careful considerations for sample-accuracy, and maybe even not make my synths/sampler JACK instruments,
but internal-only?

A channel can have one synth OR an audio input, and several Modulex instances?

Whenever there is an actual UI:  Consider alternatives to displaying waveforms or MIDI note graphs, maybe just
a plain "AUDIO" or "MIDI" label on the item, the item's name, and then editing happening in a separate pane below?

Ghosting of items...

File Saving:  Probably a plain text format like my others, once again giving XML 'the finger' (or not).  Instruments will have their own state files(just like they do now) so as not to be tied to the project(aka, you can copy the files elsewhere...)

Warp-markering type setup for audio, to make it suitable for DJing...


EDITING:

A marquee selector, and SHIFT->CLICK and CTRL->CLICK?  Maybe something like little copy checkboxes on the items instead of CTRL->click..

Splitting(or only copying/pasting partial items)

Something akin to Reaper regions...  Not necessarily regions, but the ability to copy/cut and paste things to either move what's ahead of them, or else overwrite it, but no overlapping items....

LMS Mixer Plugin:

Create a 16 channel mixer for Jack, that can accept MIDI CC volume messages per channel, and eventually gain and pan.  Most likely it should not have it's own UI???  Or maybe just hide by default?

OpenGL Rendering:

The item canvas must have a start/end point that can be related to item position.  Provisions for sample-accuracy must be made, and MIDI, etc... processed in blocks per soundcard settings (512 samples, 1024, etc...).  The blocks should be pre-calculated, and the user should not be able to edit anything during playback.  TODO:  Look at how this is currently implemented in jack and/or alsa

Drawing primitives?

Mouse-click event:  How best to efficiently handle determining what was clicked and with what modifiers?

Port the LMS_Session_Manager work to Python, and begin with a 16-track MIDI sequencer with a fixed track count, add 16 audio tracks later, then work on making it dynamic.

Track Panel == Fixed Width, Track Area = Remaining width
Zoom == Bars per area, in factors of 8(?)

Top panel == Fixed Height, Track height = remainder/track_count???

Quantize everything to 1 bar, with 1 bar being the minimum item width, and it must be an exact multiple of bars.  I'm not aware of any sane use of odd item lengths in other DAWs, although I spend a lot of time trimming and padding them to be multiples of 1 bar.

File Format Mock-up:

item0|blah|blah|blah
item0_midi_data|note-055|cc-27-120|...
...

track0|blah|blah
track0_items|item0-blah-blah-blah|item169-blah-blah-blah

# The basic idea:  A non-linear DAW, since every other DAW on the planet is excessively linear.
# A song contains X number of 8 bar regions.  Regions contain per-track items.  Items contain events.
# Events can be a MIDI note event, a MIDI CC event for automation, or playing back an audio file(?)
# The placement of an item with in a region determines what bar the item starts on in the song, but
# items within the bar may be longer than 1 bar.  The UI is completely detached from the underlying
# audio/MIDI engine, and communicates with it via a well defined protocol, which will allow easily 
# replacing the UI with a different UI, as well as safe customization of the UI.

OSC configure message keys/values:

key	value	notes

"ss"	file	Save song(file == file name)
"ns"	file	New song(file == file name)
"os"	dir|file	Open song(dir=project directory, file=.pysong file)
"si"	file	Save/update an item(file==file name)
"di"	file	Delete item(file==file name)
"sr"	file	Save/update an region(file==file name)
"dr"	file	Delete region(file==file name)
"rr"	file|file	Rename a region (old file | new file)
"ri"	file|file	Rename an item (old file | new file)
"play"	int|int	Begin playback at region|bar
"rec"	int|int	Begin recording at region|bar
"stop"	""	Stop playback or recording
"tempo"	int	The new tempo
"loop"	int	The loop mode qcombobox index #Use a LADSPA port instead?
"tsig"	int|int	Update the time signature(Not planned to be implemented anytime soon, just a placeholder for future functionality)

"vol"	"int|int"  Track volume, track#|dB
"solo"	"int|bool"	solo track, track#|bool
"mute"	"int|bool"	mute track, track#|bool

Project structure:

project/
	instruments/
		project.pyses
		*-presets.tsv
		*.u4ia
	regions/
		*.pyreg
	items/
		*.pyitem
	project.pysong
	project.pytracks
	project.pystate  #A catch-all file for things like last selected region, item, etc...  and anything else
	

*.pysong:  A | delimited representation of the song editor's QTableWidget
*.pyses :  A LMS Session Manager file containing instrument indexes
*.pyreg :  A region, with | and \n delimited representations of the QTableWidget
*.pyitem : A \t and \n delimited representation of the item editor(because the formats are already delimited with | )

#Maybe separate .pyitem into .pynotes, .pyccs and eventually .pyaudio files?

Miscellaneous TODO:
Context menus?  Stuff like, insert, delete, etc...
Euphoria: Dynamically allocate per-sample data at sample load
Implement event filter to double-click->reset-to-zero the volume sliders
Add the preset manager class to Modulex
Implement insert FX instances of Modulex
Rename this file to just 'spec.txt'
Implement the ability to specify a device + settings and stop/start the Jack server.  Then deprecate QJackCtl as a dependency...
Implement an audio specific widget kit much like the libmodsynth widgets I wrote(yet building upon the experience gained there)
Keep some sort of in-memory index of the various project files, that can be queried directly...  Maybe even a SQLite or MemcacheDB in-memory database...
Create a rudimentary piano-roll viewer using a QTableWidget, just to demonstrate how it could be accomplished for those who may fork PyDAW
Prevent overlapping notes, duplicate events, etc... in the pydaw_project classes
Implement undo, etc... functionality in the pydaw_project classes
Implement a 2-folder working-copy/saved setup, where saving a project moves it to the saved directory, and closing a project deletes the working copy.  If the project does not close cleanly, the working copy will still exist, and the user may be prompted to go with the working copy instead of the saved copy.



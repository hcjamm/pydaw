# The basic idea:  The UI is completely detached from the underlying
# audio/MIDI engine, and communicates with it via a well defined protocol of messages (and by saving files to disk then notifying to re-read the file)
# There's no chance in hell of the UI crashing the audio engine UNLESS by a bad message or file,
# which if that does happen, it will be very easy to track down and fix so that it never happens again...  Genius, right?

Startup Specifications:
	Startup(engine):
		TODO		

	Startup(UI):
		TODO		


Track types:
	0:  MIDI/plugin track
	1:  Bus track
	2:  Audio track
	3:  Audio input track

OSC configure message keys/values:

	key	value	notes

	"ss"	""	Save song
	"os"	dir	Open song(dir=project directory, file=.pysong file(without extension))
	"si"	file	Save/update an item(file==file name)
	"di"	file	Delete item(file==file name)
	"sr"	file	Save/update an region(file==file name)
	"dr"	file	Delete region(file==file name)
	"rr"	file|file	Rename a region (old file | new file)
	"ri"	file|file	Rename an item (old file | new file)
	"play"	int|int	Begin playback at region|bar
	"rec"	int|int	Begin recording at region|bar
	"stop"	""	Stop playback or recording
	"tempo"	int	The new tempo
	"loop"	int	The loop mode qcombobox index #Use a LADSPA port instead?

	"vol"	"int|int|int"  Track volume, track#|dB|type
	"solo"	"int|bool|int"	solo track, track#|bool|track_type
	"mute"	"int|bool|int"	mute track, track#|bool|track_type
	"cp"	"int|int"	Change the plugin, track# | int == 0: None, 1: Euphoria, 2: Ray-V, 3: Way-V
	"su"	int	Show the UI for track(int)
	"st"	""	Save tracks
	"tr"	int|int	Record arm a track, int:track#|int:0-not-armed/1-armed
	"fx"	int|int	show FX GUI for track(int)|track_type
	"tn"	int|string|int	Set track[int]->name to string of track_type(int)

	"preview" path	Preview a .wav or other supported sample format....  (not yet implemented)
	"or"	start-region|start-bar|end-region|end-bar|file-path	offline render project to .wav file
	"bs"	track|bus|track-type	set the mixing bus to assign the track output to

	"as"	"file-line"	Reload a single audio item, index and all data pulled from the corresponding line in the default.pydaudioitem file.
	"ac"	int	Clear the sample at index[int]
	"au"	"file-line"  Update the file at file-line, but do not reload the sample...
	"sg"	"file|uid"	Generate a sample-graph for "file", assigning it to uid.pygraph in the project/samplegraph/
	"ai"	""	Reload all audio items(the sequenced audio parts/loaded files)


Project structure:

	project/
		audio/*.wav
		audioautomation/*.pyauto
		audiofx/*.pyfx
		busautomation/*.pyauto
		busfx/*.pyfx
		instruments/
			    *.pyinst
			    *.pyfx
		items/*.pyitem
		regions/*.pyreg
		samplegraph/*.pygraph
		samples/????

		default.pygraphs #a uid-to-file-path dictionary
		default.pysong #regions
		default.pytracks #midi track
		default.pyaudio #audio tracks
		default.pyinput  #audio input configuration
		default.pytransport
		project.pydaw2  #placeholder for opening the project
	


# The basic idea:  A non-linear DAW, since every other DAW on the planet is excessively linear.
# A song contains X number of 8 bar regions.  Regions contain per-track items.  Items contain events.
# Events can be a MIDI note event, a MIDI CC event for automation, or playing back an audio file(?)
# The placement of an item with in a region determines what bar the item starts on in the song, but
# items within the bar may be longer than 1 bar.  The UI is completely detached from the underlying
# audio/MIDI engine, and communicates with it via a well defined protocol, which will allow easily 
# replacing the UI with a different UI, as well as safe customization of the UI.

Startup Specifications(to prevent the memory corruption that version 0.0.1 experiences):

	Startup(engine):

		

	Startup(UI):

		


OSC configure message keys/values:

	key	value	notes

	"ss"	""	Save song
	"os"	dir	Open song(dir=project directory, file=.pysong file(without extension))
	"si"	file	Save/update an item(file==file name)
	"di"	file	Delete item(file==file name)
	"sr"	file	Save/update an region(file==file name)
	"dr"	file	Delete region(file==file name)
	"rr"	file|file	Rename a region (old file | new file)
	"ri"	file|file	Rename an item (old file | new file)
	"play"	int|int	Begin playback at region|bar
	"rec"	int|int	Begin recording at region|bar
	"stop"	""	Stop playback or recording
	"tempo"	int	The new tempo
	"loop"	int	The loop mode qcombobox index #Use a LADSPA port instead?

	"vol"	"int|int"  Track volume, track#|dB
	"solo"	"int|bool"	solo track, track#|bool
	"mute"	"int|bool"	mute track, track#|bool
	"cp"	"int|int"	Change the plugin, track# | int == 0: None, 1: Euphoria, 2: Ray-V
	"su"	int	Show the UI for track(int)
	"st"	""	Save tracks
	"tr"	int|int	Record arm a track, int:track#|int:0-not-armed/1-armed
	"fx"	int	show FX GUI for track(int)
	"tn"	int|string	Set track[int]->name to string

	"preview" path	Preview a .wav or other supported sample format....  (not yet implemented)
	"or"	start-region|start-bar|end-region|end-bar|file-path	offline render project to .wav file
	"bs"	track|bus	set the mixing bus to assign the track output to

	"al"	""	Reload audio tracks(the sequenced audio parts/loaded files)
	"as"	""	Save audio tracks(the tracks, ie:  volume, name, mute, solo...)
	"af"	int	Open the FX GUI for audio_track[int]
	"ai"	""	Save the audio input busses(rec arm, default audio track, mono/stereo/mixed, etc...)

Project structure:

	project/
		instruments/
			project.pyses
			*-presets.tsv
			*.u4ia
		regions/
			*.pyreg
		items/
			*.pyitem
		project.pysong
		project.pytracks
		project.pystate  #A catch-all file for things like last selected region, item, etc...  and anything else
	

	*.pysong:  A | delimited representation of the song editor's QTableWidget
	*.pyses :  A LMS Session Manager file containing instrument indexes
	*.pyreg :  A region, with | and \n delimited representations of the QTableWidget
	*.pyitem : A \t and \n delimited representation of the item editor(because the formats are already delimited with | )

	#Maybe separate .pyitem into .pynotes, .pyccs and eventually .pyaudio files?

Miscellaneous TODO:
	An indexing algorithm in the C back-end for resolving item name to array index.
	Liblo stuff needs to be initialized before we start setting up anything that send
	Add an item_editor combobox and a region_editor combobox, then have a default item and region opened when the project opens
	Euphoria: Dynamically allocate per-sample data at sample load
	Implement event filter to double-click->reset-to-zero the volume sliders
	Add the preset manager class to Modulex
	Implement insert FX instances of Modulex
	Rename this file to just 'spec.txt'
	Implement the ability to specify a device + settings and stop/start the Jack server.  Then deprecate QJackCtl as a dependency...
	Implement an audio specific widget kit much like the libmodsynth widgets I wrote(yet building upon the experience gained there)
	Keep some sort of in-memory index of the various project files, that can be queried directly...  Maybe even a SQLite or MemcacheDB in-memory database...
	Prevent overlapping notes, duplicate events, etc... in the pydaw_project classes
	Implement undo, etc... functionality in the pydaw_project classes
	Implement a 2-folder working-copy/saved setup, where saving a project moves it to the saved directory, and closing a project deletes the working copy.  If the project does not close cleanly, the working copy will still exist, and the user may be prompted to go with the working copy instead of the saved copy.


	Context menus?  Stuff like, insert, delete, etc...

	   1 import sys
	   2 from PyQt4.QtCore import Qt
	   3 from PyQt4.QtGui import *
	   4 
	   5 app = QApplication([])
	   6 tableWidget = QTableWidget()
	   7 tableWidget.setContextMenuPolicy(Qt.CustomContextMenu)
	   8 
	   9 def openMenu(position): #The signal delivers a QPoint value
	  10 
	  11     menu = QMenu()
	  12     quitAction = menu.addAction("Quit")
	  13     action = menu.exec_(tableWidget.mapToGlobal(position))
	  14     if action == quitAction:
	  15         qApp.quit()
	  16 
	  17 tableWidget.customContextMenuRequested.connect(openMenu)
	  18 tableWidget.show()
	  19 sys.exit(app.exec_()




	Create a rudimentary piano-roll viewer using a QTableWidget, just to demonstrate how it could be accomplished for those who may fork PyDAW.  Some relevant code snippets from the internet:

	item=new QTableWidgetItem("text for the row header");
	item->setBackground(QBrush(QColor(255,0,0)); //red background
	item->setForeground(QBrush(QColor(0,255,0)); // green text
	my_table->setVerticalHeaderItem(r, item); // item is placed on the header of row r

	import sys
	from PyQt4 import QtGui
	from PyQt4 import QtCore

	class Button(QtGui.QPushButton):

	    def __init__(self, title, parent):
		super(Button, self).__init__(title, parent)

	    def mouseMoveEvent(self, e):
		if e.buttons() != QtCore.Qt.RightButton:
		    return 

		mimeData = QtCore.QMimeData()
		drag = QtGui.QDrag(self)
		drag.setMimeData(mimeData)
		drag.setHotSpot(e.pos() - self.rect().topLeft())

		dropAction = drag.start(QtCore.Qt.MoveAction)

	    def mousePressEvent(self, e):
		if e.button() == QtCore.Qt.LeftButton:
		    print 'Left Button Pressed'


	class MyTable(QtGui.QTableWidget):

	    def __init__(self, rows, columns, butObject, parent):
		super(MyTable, self).__init__(rows, columns, parent)
		self.setAcceptDrops(True)
		self.butObject = butObject

	    def dragEnterEvent(self, e):
		e.accept()


	When you drop the button into the table, does the 'print position' work? It should be printing out the coords of the drop position to your shell. I think you need to use those to then insert the button into the table.

	Got it working - change your drop event to this:

	    position = e.pos()

	    print position

	    row = self.rowAt(position.y())

	    column = self.columnAt(position.x())

	    self.setCellWidget(row,column,self.butObject)

	    e.setDropAction(QtCore.Qt.MoveAction)
	    e.accept()
	 

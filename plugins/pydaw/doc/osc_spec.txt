# The basic idea:  A non-linear DAW, since every other DAW on the planet is excessively linear.
# A song contains X number of 8 bar regions.  Regions contain per-track items.  Items contain events.
# Events can be a MIDI note event, a MIDI CC event for automation, or playing back an audio file(?)
# The placement of an item with in a region determines what bar the item starts on in the song, but
# items within the bar may be longer than 1 bar.  The UI is completely detached from the underlying
# audio/MIDI engine, and communicates with it via a well defined protocol, which will allow easily 
# replacing the UI with a different UI, as well as safe customization of the UI.

OSC configure message keys/values:

key	value	notes

"ss"	file	Save song(file == file name)
"ns"	file	New song(file == file name)
"us"	file	Update Song(file==file name)
"os"	dir|file	Open song(dir=project directory, file=.pysong file)
"ni"	file	New item(file==file name)
"ui"	file	Update an item(file==file name)
"di"	file	Delete item(file==file name)
"nr"	file	New region(file==file name)
"ur"	file	Update an region(file==file name)
"dr"	file	Delete region(file==file name)
"rr"	file|file	Rename a region (old file | new file)
"ri"	file|file	Rename an item (old file | new file)
"play"	""	Begin playback
"rec"	""	Begin recording
"stop"	""	Stop playback or recording
"tempo"	int	The new tempo
"loop"	int	The loop mode qcombobox index #Use a LADSPA port instead?

"vol"	"int|int"  Track volume, track#|dB
"solo"	"int|bool"	solo track, track#|bool
"mute"	"int|bool"	mute track, track#|bool

Project structure:

project/
	instruments/
		project.pyses
		*-presets.tsv
	regions/
		*.pyreg
	items/
		*.pyitem
	project.pysong
	project.pytracks
	

*.pysong:  A | delimited representation of the song editor's QTableWidget
*.pyses :  A LMS Session Manager file containing instrument indexes
*.pyreg :  A region, with | and \n delimited representations of the QTableWidget
*.pyitem : A \t and \n delimited representation of the item editor(because the formats are already delimited with | )

#Maybe separate .pyitem into .pynotes, .pyccs and eventually .pyaudio files?

Miscellaneous TODO:
Context menus?  Stuff like, insert, delete, etc...
Euphoria: Dynamically allocate per-sample data at sample load
Create a tabwidget for the main area, and move the item editor to a new tab.  Later I can add audio and MIDI event lists...
Implement event filter to double-click->reset-to-zero the volume sliders
Add the preset manager class to Modulex
Implement insert FX instances of Modulex
Rename this file to just 'spec.txt'
Implement the ability to specify a device + settings and stop/start the Jack server.  Then deprecate QJackCtl as a dependency...
Implement an audio specific widget kit much like the libmodsynth widgets I wrote(yet building upon the experience gained there)
Keep some sort of in-memory index of the various project files, that can be queried directly...  Maybe even a SQLite or MemcacheDB in-memory database...


TODO for today:

7.  When opening an existing project, read the tracks[] from the session_mgr and update track_editor


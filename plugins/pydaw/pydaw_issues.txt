Notes on current bugs in PyDAW, as well as pseudo-roadmap stuff


How jack_lsp is currently listing ports(note the spaces in PyDAW in/out, and the jacked up names for Ray-V):
	system:capture_1
	system:capture_2
	system:capture_3
	system:capture_4
	system:capture_5
	system:capture_6
	system:capture_7
	system:capture_8
	firewire_pcm:C8_00130e040240212b_midi 0
	system:playback_1
	system:playback_2
	system:playback_3
	system:playback_4
	system:playback_5
	system:playback_6
	system:playback_7
	system:playback_8
	system:playback_9
	system:playback_10
	system:playback_11
	system:playback_12
	firewire_pcm:P12_00130e040240212b_midi 0
	PyDAW:PyDAW in_1
	...
	PyDAW:PyDAW in_16
	PyDAW:PyDAW out_1
	PyDAW:PyDAW out_2
	/home/****/default-track0:out_0
	/home/****/default-track0:out_1

~/default.pss looks like this, which is an obvious bug:

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

0|

Also, rename .pss extension to .pydaw or something...

dssi_gui: The @make_method decorator should be replaced with explicitly adding methods... 

The top area of the main window shouldn't be part of the scroll area

Need a dropdown for selecting an ALSA MIDI device, then make the Rec checkbox only available to one track at a time for recording...  If hacking it with aconnect, just use aconnect -o to get a list, aconnect -i to determine which client:port PyDAW is, then aconnect client:port client:port to connect, then aconnect -d client:port client:port when moving to a different track

Use configure messages for pretty much everything, and keep a history of them to allow undo-ing of various actions

The exit handler doesn't actually cause it to exit when the UI is closed.  AFAIK, the destructor is never being called...

Need to be able to set tempo...

A list editor for midi events...

Deprecate the current widget library and replace with a custom library based on textures...

Write a Python module for Jack and Alsa...  Or maybe just enumerate a list into the project directory, with the assumption that those devices will always be there...

Figure out what function is being called on widget move to un-jumble everything, and call it at startup...

Perhaps just cheat and parse the output of jack_lsp, aconnect, etc...  I can always go back and do it right later...

Figure out a MIDI file format, with calculated sample accuracy from the UI, etc...  Initially, use the name of the MIDI item for the file name, as well as ghosting....

Figure out a way for the UI to determine that playback is happening and move the cursor accordingly...

Create 8 bar 'sets' that can be used for writing entire songs, with buttons for previous/next, and a little spinbox widget that shows which one you are on...  Maybe use less than 16 instruments for the initial version, maybe just 8?

Audio sequencing:  Introduce a pool of items, that can be selected in an event list similar to (or alongside?) the MIDI events.  Have the option of a smooth/unsmooth mode for CCs(per CC, per track?)...

A series of comboboxes to serve as a menustrip, with File->Save,Save As, Open, New, etc....

Sequencing engine:  Perhaps just keep the underlying C in the simplest terms possible, and let the UI generate configure messages like key:note_on value:127|23321 and key:note_off value:0|24566, etc...  The UI could also tell the engine exactly what sample to execute on, but that may pose a problem when changing tempo?  When changing play cursor positions, editing, each track should keep an index of the next

Sequencing engine, take 2:  The first idea probably isn't workable, this actually needs to be calculated at the beginning of each bar, which coincides with the end of a previous bar....  The C engine calculates the length of a bar in samples when the tempo changes

ALSA latency compensation:  Apparently devices can report latency,  use that to offset....

